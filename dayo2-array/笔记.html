es6数组扩展


1、find方法  返回值：查找数组中 符合条件的第一项；差找不到返回undefined
[].find(ck,thisobj)
Array.prototype.find()
2、findIndex方法  返回值：符合条件的第一项的下标；查到不到-1
3、filter 过滤  返回值：所有符合条件的项 数组

3、entries()，keys() 和 values()
4、copyWithin(target, start = 0, end = this.length) 会改变原数组
5、includes() 是否包含参数（值，位置index） 返回值 true、false
//====
Array.from()  将类数组对象转化为真正的数组
let obj={0:'jin',1:18,length:2}
Array.isArray() 判断给定的数据类型是否是Array   typeof
Array.of() 类似于 new Array()
//=====
for...of 遍历 可迭代的对象 比如：数组、map、set、arguments
for (variable of iterable) {
    statement
}

for-of 不可以遍历普通对象
const obj = { fname: 'foo', lname: 'bar' };
 
for (const value of obj) { // TypeError: obj[Symbol.iterator] is not a function
    console.log(value);
}



es6函数扩展  箭头函数（重点）
特点：
1、箭头函数相当于匿名函数，并且简化了函数定义
let fun = () => {
    console.log('lalalala');
}
function fun() {
    console.log('lalla');
}
2、箭头函数是匿名函数，不能作为构造函数，不能使用new
let Person = () => {
    console.log('lll');
}

let p = new Person();

普通构造器函数
function Person(name,age){
    this.name=name
    this.age=age
}
var p = new Person('jim',19)

3、箭头函数不绑定arguments，取而代之用rest参数...解决
let demo = (b)=>{
    console.log(arguments);
  }
  demo(1,2,3,4)
4、this指向问题
重点：箭头函数中的this是在定义函数的时候绑定，而不是在执行函数的时候绑定。
（1）由于箭头函数不绑定this， 它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值
var obj = {
    i: 10,
    b: () => console.log( this),
    c: function() {
      console.log(this)
    }
  }
  注意：对象内部方法的this指向调用这些方法的对象，
  （2）
  对于延时函数内部的回调函数的this指向全局对象window

  //默认情况下代码
function Person() {  
    this.age = 0;  
    setTimeout(function() {
        console.log(this);
    }, 3000);
}

var p = new Person();//3秒后返回 window 对象

vs:捕获上下文中的this
function Person() {  
    this.age = 0;  
    setInterval(() => {
        // 回调里面的 `this` 变量就指向了期望的那个对象了
        this.age++;
    }, 3000);
}

var p = new Person();

5、箭头函数没有原型属性
var a = ()=>{
    return 1;
}
  
function b(){
return 2;
}
  
console.log(a.prototype);  // undefined
console.log(b.prototype);   // {constructor: ƒ}



====对象Object.defineproperty  object.getownpropertydescriptor 
object.assign()  
object.keys()  values() entries()

===字符串方法
includes  是否包含 返回布尔值